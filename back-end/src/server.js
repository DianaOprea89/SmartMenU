// server.js
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import bcrypt from 'bcrypt';
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';
import User from './schemas/user.model.js';
import 'express-async-errors';

dotenv.config();

const app = express();

const corsOptions = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204,
};

app.use(cors(corsOptions));
app.use(bodyParser.json());

console.log("Connecting to MongoDB at:", process.env.MONGODB_URI);

mongoose.connect(process.env.MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true
}).then(() => {
    console.log('Connected to MongoDB...');
}).catch(err => {
    console.error('Could not connect to MongoDB...', err);
    process.exit(1); // Exit with failure code
});



app.use((req, res, next) => {
    console.log(`Request received: ${req.method} ${req.url}`);
    next();
});

app.get('/api/userData', async (req, res) => {
    const token = req.headers.authorization?.split(' ')[1]; // Authorization: 'Bearer TOKEN'

    if (!token) {
        return res.status(401).json({ message: 'No token provided' });
    }

    try {
        // Verify the token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        // Use the user ID in the decoded token to look up the user in the database
        const user = await User.findById(decoded.userId);

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Send back the user data
        res.status(200).json({
            name: user.username, // Make sure you are using the correct field for the user's name
            email: user.email,
            id: user._id, // Use _id (the field automatically generated by MongoDB)
            restaurants: user.restaurants
        });
    } catch (error) {
        console.error(error); // Log the error to get more details
        if (error.name === 'TokenExpiredError') {
            res.status(401).json({ message: 'Token expired' });
        } else if (error.name === 'JsonWebTokenError') {
            res.status(401).json({ message: 'Invalid token' });
        } else {
            res.status(500).json({ message: 'Internal server error' });
        }
    }

});


app.post('/api/register', async (req, res) => {
    try {
        const { name, email, password, passwordConfirm } = req.body;
        console.log(req.body);


        if (!name || !email || !password || !passwordConfirm) {
            console.log("Missing fields:", { name, email, password, passwordConfirm });
            return res.status(400).json({ message: 'Please fill all fields' });
        }

        if (password !== passwordConfirm) {
            return res.status(400).json({ message: 'Passwords do not match' });
        }

        // Simple regex for basic email validation
        const emailRegex = /^(([^<>()\]\\.,;:\s@"]+(\.[^<>()\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        if (!emailRegex.test(email)) {
            return res.status(400).json({ message: 'Invalid email format' });
        }

        const existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(400).json({ message: 'Email already in use' });
        }

        const hashedPassword = await bcrypt.hash(password, 10);

        const user = new User({
            username: name, // Ensure this matches your schema
            email,
            passwordHash: hashedPassword
        });

        await user.save();

        // Send minimal user information back
        res.status(201).json({
            message: 'User registered successfully',
            user: { username: user.username, email } // Don't send back the password or hashed password
        });
    } catch (error) {
        console.error('Registration error:', error);
        // Send generic error message to client
        res.status(500).json({ message: 'Error registering user' });
    }
});


app.post('/api/login', async (req, res) => {
    try {
        const { email, password } = req.body;

        const user = await User.findOne({ email });
        if (!user) {
            return res.status(400).json({ message: 'User does not exist' });
        }

        const validPassword = await bcrypt.compare(password, user.passwordHash);

        if (!validPassword) {
            return res.status(400).json({ message: 'Invalid password' });
        }

        const token = jwt.sign(
            { userId: user._id, email: user.email },
            process.env.JWT_SECRET,
            { expiresIn: process.env.JWT_EXPIRES_IN }
        );

        res.status(200).json({
            message: 'Logged in successfully',
            token,
            user: {
                name: user.username,
                email: user.email
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ message: 'Error logging in user' });
    }
});


app.post('/api/restaurants', async (req, res) => {
    try {
        // Extract user ID, restaurant name, and new menu option data from request body
        const { userId, name, newItem } = req.body;

        // Verify the user's token and extract their ID (you can add token verification here if needed)

        // Find the user by their ID
        const user = await User.findById(userId);

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Find the restaurant by name within the user's restaurants
        const restaurant = user.restaurants.find(r => r.name === name);

        if (!restaurant) {
            return res.status(404).json({ message: 'Restaurant not found' });
        }

        // Add the new menu option to the restaurant's menuOptions array
        restaurant.menuOptions.push(newItem);

        // Save the updated user data
        await user.save();

        // Send back the updated user data
        res.status(200).json({
            message: 'Menu option added successfully',
            user: user // Return the updated user data
        });
    } catch (error) {
        console.error('Error adding menu option:', error);
        res.status(500).json({ message: 'Error adding menu option' });
    }
});





app.get('/test', (req, res) => {
    res.send('The test route is working');
});
// A generic error handler middleware after all routes
app.use(function (err, req, res, next) {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});


const PORT = process.env.PORT || 8008;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
